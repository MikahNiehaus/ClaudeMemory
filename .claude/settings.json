{
  "permissions": {
    "allow": [
      "Read",
      "Write",
      "Edit",
      "Glob",
      "Grep",
      "Task",
      "TodoWrite",
      "NotebookEdit",
      "WebSearch",
      "WebFetch",
      "AskUserQuestion",
      "Bash(npm:*)",
      "Bash(npx:*)",
      "Bash(node:*)",
      "Bash(python:*)",
      "Bash(pip:*)",
      "Bash(pytest:*)",
      "Bash(jest:*)",
      "Bash(vitest:*)",
      "Bash(tsc:*)",
      "Bash(eslint:*)",
      "Bash(prettier:*)",
      "Bash(cargo:*)",
      "Bash(go:*)",
      "Bash(dotnet:*)",
      "Bash(mvn:*)",
      "Bash(gradle:*)",
      "Bash(make:*)",
      "Bash(cmake:*)",
      "Bash(ls:*)",
      "Bash(pwd)",
      "Bash(cd:*)",
      "Bash(mkdir:*)",
      "Bash(cp:*)",
      "Bash(mv:*)",
      "Bash(touch:*)",
      "Bash(chmod:*)",
      "Bash(wc:*)",
      "Bash(sort:*)",
      "Bash(uniq:*)",
      "Bash(diff:*)",
      "Bash(git status)",
      "Bash(git status:*)",
      "Bash(git diff)",
      "Bash(git diff:*)",
      "Bash(git log)",
      "Bash(git log:*)",
      "Bash(git show:*)",
      "Bash(git blame:*)",
      "Bash(git rev-parse:*)",
      "Bash(git branch)",
      "Bash(git branch -a)",
      "Bash(git branch -r)",
      "Bash(git branch -v)",
      "Bash(git branch --list:*)",
      "Bash(git remote -v)",
      "Bash(git remote show:*)",
      "Bash(git tag)",
      "Bash(git tag -l:*)",
      "Bash(git ls-files:*)",
      "Bash(git ls-tree:*)",
      "Bash(git shortlog:*)",
      "Bash(git describe:*)",
      "Bash(git config --list)",
      "Bash(git config --get:*)",
      "Bash(gh issue:*)",
      "Bash(gh pr list:*)",
      "Bash(gh pr view:*)",
      "Bash(gh pr status)",
      "Bash(gh pr checks:*)",
      "Bash(gh repo view:*)",
      "Bash(docker ps:*)",
      "Bash(docker images:*)",
      "Bash(docker logs:*)",
      "Bash(docker inspect:*)",
      "Bash(which:*)",
      "Bash(where:*)",
      "Bash(type:*)",
      "Bash(env)",
      "Bash(printenv:*)",
      "Bash(date:*)",
      "Bash(whoami)",
      "Bash(hostname)"
    ],
    "ask": [
      "Bash(cat:*)",
      "Bash(head:*)",
      "Bash(tail:*)",
      "Bash(echo:*)",
      "Bash(git add:*)",
      "Bash(git add)",
      "Bash(git commit:*)",
      "Bash(git commit)",
      "Bash(git push:*)",
      "Bash(git push)",
      "Bash(git pull:*)",
      "Bash(git pull)",
      "Bash(git fetch:*)",
      "Bash(git fetch)",
      "Bash(git merge:*)",
      "Bash(git merge)",
      "Bash(git rebase:*)",
      "Bash(git rebase)",
      "Bash(git checkout:*)",
      "Bash(git checkout)",
      "Bash(git switch:*)",
      "Bash(git switch)",
      "Bash(git restore:*)",
      "Bash(git restore)",
      "Bash(git reset:*)",
      "Bash(git reset)",
      "Bash(git revert:*)",
      "Bash(git revert)",
      "Bash(git cherry-pick:*)",
      "Bash(git cherry-pick)",
      "Bash(git stash:*)",
      "Bash(git stash)",
      "Bash(git clean:*)",
      "Bash(git clean)",
      "Bash(git branch -d:*)",
      "Bash(git branch -D:*)",
      "Bash(git branch --delete:*)",
      "Bash(git branch -m:*)",
      "Bash(git branch -M:*)",
      "Bash(git branch --move:*)",
      "Bash(git branch -c:*)",
      "Bash(git branch --copy:*)",
      "Bash(git tag -d:*)",
      "Bash(git tag -a:*)",
      "Bash(git tag --delete:*)",
      "Bash(git remote add:*)",
      "Bash(git remote remove:*)",
      "Bash(git remote rename:*)",
      "Bash(git remote set-url:*)",
      "Bash(git config --global:*)",
      "Bash(git config --system:*)",
      "Bash(git config --local:*)",
      "Bash(git config --unset:*)",
      "Bash(git init:*)",
      "Bash(git init)",
      "Bash(git clone:*)",
      "Bash(git clone)",
      "Bash(git submodule:*)",
      "Bash(git filter-branch:*)",
      "Bash(git reflog expire:*)",
      "Bash(git gc:*)",
      "Bash(git prune:*)",
      "Bash(git rm:*)",
      "Bash(git mv:*)",
      "Bash(git apply:*)",
      "Bash(git am:*)",
      "Bash(git format-patch:*)",
      "Bash(git worktree:*)",
      "Bash(git bisect:*)",
      "Bash(gh pr create:*)",
      "Bash(gh pr merge:*)",
      "Bash(gh pr close:*)",
      "Bash(gh pr edit:*)",
      "Bash(gh issue create:*)",
      "Bash(gh issue close:*)",
      "Bash(gh issue edit:*)",
      "Bash(gh repo create:*)",
      "Bash(gh repo delete:*)",
      "Bash(gh release:*)",
      "Bash(rm -rf:*)",
      "Bash(rm -r /*)",
      "Bash(sudo:*)",
      "Bash(chmod 777:*)",
      "Bash(curl:*)",
      "Bash(wget:*)",
      "Read(./.env)",
      "Read(./.env.*)",
      "Read(./.env.local)",
      "Read(./.env.production)",
      "Read(./secrets/**)",
      "Read(./**/secrets/**)",
      "Read(./**/*.pem)",
      "Read(./**/*.key)",
      "Read(./**/credentials*)",
      "Read(./**/*_secret*)",
      "Read(./**/*_token*)",
      "Read(~/.ssh/**)",
      "Read(~/.aws/**)",
      "Read(~/.config/gcloud/**)",
      "Write(./.env)",
      "Write(./.env.*)",
      "Write(./secrets/**)",
      "Edit(./.env)",
      "Edit(./.env.*)",
      "Edit(./secrets/**)"
    ],
    "deny": [],
    "additionalDirectories": []
  },
  "sandbox": {
    "enabled": true,
    "autoAllowBashIfSandboxed": true,
    "excludedCommands": ["docker", "git"],
    "network": {
      "allowLocalBinding": true
    }
  },
  "includeCoAuthoredBy": true,
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit",
        "hooks": [
          {
            "type": "prompt",
            "prompt": "ENFORCEMENT CHECK: A file edit is about to occur. Analyze if this edit involves: testing, debugging, architecture, security, refactoring, or significant code changes. If the edit involves any specialized domain, verify that an appropriate agent (test-agent, debug-agent, architect-agent, security-agent, refactor-agent) was consulted in this conversation. Respond ONLY with 'ALLOW' if: (1) appropriate agent was consulted, OR (2) this is a trivial edit (typo, comment, formatting, config file). Respond with 'BLOCK: Must spawn [agent-name] before this edit' if a required agent was not consulted. Input: $ARGUMENTS",
            "timeout": 30,
            "statusMessage": "Validating agent compliance..."
          }
        ]
      },
      {
        "matcher": "Write",
        "hooks": [
          {
            "type": "prompt",
            "prompt": "ENFORCEMENT CHECK: A new file is being created. If this file contains: test code (verify test-agent consulted), application logic (verify appropriate agent consulted), security-related code (verify security-agent consulted). Respond ONLY with 'ALLOW' if appropriate agent was consulted OR file is configuration/documentation only. Respond with 'BLOCK: Must spawn [agent-name] first' if required agent was not consulted. Input: $ARGUMENTS",
            "timeout": 30,
            "statusMessage": "Validating agent compliance..."
          }
        ]
      },
      {
        "matcher": "Task",
        "hooks": [
          {
            "type": "prompt",
            "prompt": "AGENT SPAWN VALIDATION: Check that the Task prompt includes ALL of the following: (1) Full agent definition from agents/[name]-agent.md (Role, Goal, Backstory, Capabilities sections), (2) Full knowledge base from knowledge/[topic].md, (3) Task context with workspace path or task ID, (4) Clear task instructions, (5) Expected output format with Status field requirement. Respond 'ALLOW' if all five components are present. Respond 'BLOCK: Missing [component]' if any are incomplete or summarized instead of full content. Input: $ARGUMENTS",
            "timeout": 60,
            "statusMessage": "Validating agent compliance..."
          }
        ]
      }
    ],
    "SessionStart": [
      {
        "matcher": "Always",
        "hooks": [
          {
            "type": "prompt",
            "prompt": "SESSION INITIALIZATION: Read MEMORY.md and check the Active Tasks table. If any tasks have status ACTIVE or BLOCKED, summarize them briefly (task ID, description, current status). Identify which task should be resumed first based on priority. Also remind that CLAUDE.md contains orchestrator instructions.",
            "statusMessage": "Loading session state...",
            "timeout": 20
          }
        ]
      }
    ],
    "PreCompact": [
      {
        "matcher": "auto",
        "hooks": [
          {
            "type": "prompt",
            "prompt": "COMPACTION PREPARATION: Before context is compacted, ensure critical state is preserved. For each active task in workspace/[task-id]/: (1) Verify context.md has updated Status, (2) Verify Next Steps are documented, (3) Verify Key Findings are recorded. Include in compaction summary: active task IDs, current agent status, blocking issues, and what to resume. This information MUST survive compaction.",
            "statusMessage": "Preparing for compaction...",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
